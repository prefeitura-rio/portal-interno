/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Heimdall Admin Service
 * # Heimdall Admin Service API

A comprehensive admin service for user and group management with authorization powered by Cerbos.

## Features

- **User Management**: Automatic user creation from JWT tokens with role-based access control
- **Group Management**: Create, manage, and assign users to groups with hierarchical permissions
- **Role Management**: Define and assign roles to users and groups
- **Mapping Management**: Configure API endpoint to action mappings for authorization
- **Action Management**: Define available actions for fine-grained permission control
- **Cerbos Integration**: Policy-based authorization with external Cerbos service
- **Audit Logging**: Comprehensive audit trail for all administrative operations
- **Redis Caching**: High-performance caching for frequently accessed data
 * OpenAPI spec version: 1.0.0
 */
import type {
  HTTPValidationError,
  ListMappingsApiV1MappingsListGetParams,
  MappingCreateRequest,
  MappingDetailResponse,
  MappingUpdateRequest,
  ResolveMappingApiV1MappingsGet200,
  ResolveMappingApiV1MappingsGetParams,
} from '.././models'

import { customFetchHeimdall } from '../../../custom-fetch-heimdall'

/**
 * Resolve an API endpoint (path + method) to its corresponding action for authorization.

**Authorization Middleware**: This endpoint is primarily used by authorization middleware
to determine which action should be checked for a given API request.

**Path Matching**: Supports exact matches and pattern matching with path parameters
(e.g., `/api/v1/users/{user_id}` matches `/api/v1/users/123`).

**Method Matching**: HTTP method must match exactly (case-sensitive).

**Use Cases**:
- Authorization middleware determining required permissions
- API gateway integration for access control
- Dynamic permission checking in applications
- Audit logging of permission requirements
 * @summary Resolve endpoint to action
 */
export type resolveMappingApiV1MappingsGetResponse200 = {
  data: ResolveMappingApiV1MappingsGet200
  status: 200
}

export type resolveMappingApiV1MappingsGetResponseComposite =
  resolveMappingApiV1MappingsGetResponse200

export type resolveMappingApiV1MappingsGetResponse =
  resolveMappingApiV1MappingsGetResponseComposite & {
    headers: Headers
  }

export const getResolveMappingApiV1MappingsGetUrl = (
  params: ResolveMappingApiV1MappingsGetParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/mappings/?${stringifiedParams}`
    : `/api/v1/mappings/`
}

export const resolveMappingApiV1MappingsGet = async (
  params: ResolveMappingApiV1MappingsGetParams,
  options?: RequestInit
): Promise<resolveMappingApiV1MappingsGetResponse> => {
  return customFetchHeimdall<resolveMappingApiV1MappingsGetResponse>(
    getResolveMappingApiV1MappingsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

/**
 * Create a new mapping between an API endpoint pattern and an action.

**Authorization**: Requires admin privileges to create mappings.

**Path Patterns**: Support exact paths and parameterized paths using curly braces
(e.g., `/api/v1/users/{user_id}`, `/api/v1/groups/{group_name}/members`).

**Method Mapping**: Each combination of path pattern and HTTP method can only
be mapped to one action.

**Action Reference**: The action must exist before creating a mapping. Use the
actions API to create actions first.

**Use Cases**:
- Configure authorization for new API endpoints
- Map existing endpoints to granular permissions
- Set up fine-grained access control
- Administrative configuration of API security
 * @summary Create endpoint-to-action mapping
 */
export type createMappingApiV1MappingsPostResponse201 = {
  data: MappingDetailResponse
  status: 201
}

export type createMappingApiV1MappingsPostResponseComposite =
  createMappingApiV1MappingsPostResponse201

export type createMappingApiV1MappingsPostResponse =
  createMappingApiV1MappingsPostResponseComposite & {
    headers: Headers
  }

export const getCreateMappingApiV1MappingsPostUrl = () => {
  return `/api/v1/mappings/`
}

export const createMappingApiV1MappingsPost = async (
  mappingCreateRequest: MappingCreateRequest,
  options?: RequestInit
): Promise<createMappingApiV1MappingsPostResponse> => {
  return customFetchHeimdall<createMappingApiV1MappingsPostResponse>(
    getCreateMappingApiV1MappingsPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(mappingCreateRequest),
    }
  )
}

/**
 * Update an existing endpoint-to-action mapping.

**Authorization**: Requires admin privileges to update mappings.

**Partial Updates**: You can update individual fields (path_pattern, method, action_id, description)
without affecting others. Provide only the fields you want to change.

**Validation**: The new path pattern and method combination must not conflict
with existing mappings (unless it's the same mapping being updated).

**Action Reference**: If updating action_id, the new action must exist.

**Use Cases**:
- Update endpoint patterns when API paths change
- Change the action associated with an endpoint
- Update descriptions for better documentation
- Administrative maintenance of authorization configuration
 * @summary Update endpoint mapping
 */
export type updateMappingApiV1MappingsMappingIdPutResponse200 = {
  data: MappingDetailResponse
  status: 200
}

export type updateMappingApiV1MappingsMappingIdPutResponseComposite =
  updateMappingApiV1MappingsMappingIdPutResponse200

export type updateMappingApiV1MappingsMappingIdPutResponse =
  updateMappingApiV1MappingsMappingIdPutResponseComposite & {
    headers: Headers
  }

export const getUpdateMappingApiV1MappingsMappingIdPutUrl = (
  mappingId: number
) => {
  return `/api/v1/mappings/${mappingId}`
}

export const updateMappingApiV1MappingsMappingIdPut = async (
  mappingId: number,
  mappingUpdateRequest: MappingUpdateRequest,
  options?: RequestInit
): Promise<updateMappingApiV1MappingsMappingIdPutResponse> => {
  return customFetchHeimdall<updateMappingApiV1MappingsMappingIdPutResponse>(
    getUpdateMappingApiV1MappingsMappingIdPutUrl(mappingId),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(mappingUpdateRequest),
    }
  )
}

/**
 * Delete an endpoint-to-action mapping from the system.

**Authorization**: Requires admin privileges to delete mappings.

**Impact**: Deleting a mapping will remove authorization requirements for the
corresponding endpoint. Requests to that endpoint will no longer be checked
against the associated action.

**Idempotent Operation**: Attempting to delete a non-existent mapping returns
success (204) for idempotent behavior.

**Use Cases**:
- Remove authorization for deprecated endpoints
- Clean up unused or incorrect mappings
- Administrative maintenance of authorization configuration

**Warning**: Ensure the endpoint should no longer require authorization before
deleting its mapping.
 * @summary Delete endpoint mapping
 */
export type deleteMappingApiV1MappingsMappingIdDeleteResponse204 = {
  data: null
  status: 204
}

export type deleteMappingApiV1MappingsMappingIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteMappingApiV1MappingsMappingIdDeleteResponseComposite =
  | deleteMappingApiV1MappingsMappingIdDeleteResponse204
  | deleteMappingApiV1MappingsMappingIdDeleteResponse422

export type deleteMappingApiV1MappingsMappingIdDeleteResponse =
  deleteMappingApiV1MappingsMappingIdDeleteResponseComposite & {
    headers: Headers
  }

export const getDeleteMappingApiV1MappingsMappingIdDeleteUrl = (
  mappingId: number
) => {
  return `/api/v1/mappings/${mappingId}`
}

export const deleteMappingApiV1MappingsMappingIdDelete = async (
  mappingId: number,
  options?: RequestInit
): Promise<deleteMappingApiV1MappingsMappingIdDeleteResponse> => {
  return customFetchHeimdall<deleteMappingApiV1MappingsMappingIdDeleteResponse>(
    getDeleteMappingApiV1MappingsMappingIdDeleteUrl(mappingId),
    {
      ...options,
      method: 'DELETE',
    }
  )
}

/**
 * Retrieve a list of all endpoint-to-action mappings with optional filtering.

**Authorization**: All authenticated users can list mappings.

**Filtering**: Use the action_filter parameter to show only mappings for
a specific action (exact match on action name).

**Management Interface**: This endpoint is designed for administrative
interfaces and configuration management tools.

**Use Cases**:
- Display current authorization configuration
- Administrative overview of endpoint mappings
- Audit and compliance reporting
- Integration with external configuration management
- Troubleshooting authorization issues
 * @summary List all endpoint mappings
 */
export type listMappingsApiV1MappingsListGetResponse200 = {
  data: MappingDetailResponse[]
  status: 200
}

export type listMappingsApiV1MappingsListGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listMappingsApiV1MappingsListGetResponseComposite =
  | listMappingsApiV1MappingsListGetResponse200
  | listMappingsApiV1MappingsListGetResponse422

export type listMappingsApiV1MappingsListGetResponse =
  listMappingsApiV1MappingsListGetResponseComposite & {
    headers: Headers
  }

export const getListMappingsApiV1MappingsListGetUrl = (
  params?: ListMappingsApiV1MappingsListGetParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/mappings/list?${stringifiedParams}`
    : `/api/v1/mappings/list`
}

export const listMappingsApiV1MappingsListGet = async (
  params?: ListMappingsApiV1MappingsListGetParams,
  options?: RequestInit
): Promise<listMappingsApiV1MappingsListGetResponse> => {
  return customFetchHeimdall<listMappingsApiV1MappingsListGetResponse>(
    getListMappingsApiV1MappingsListGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}
