/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * Heimdall Admin Service
 * # Heimdall Admin Service API

A comprehensive admin service for user and group management with authorization powered by Cerbos.

## Features

- **User Management**: Automatic user creation from JWT tokens with role-based access control
- **Group Management**: Create, manage, and assign users to groups with hierarchical permissions
- **Role Management**: Define and assign roles to users and groups
- **Mapping Management**: Configure API endpoint to action mappings for authorization
- **Action Management**: Define available actions for fine-grained permission control
- **Cerbos Integration**: Policy-based authorization with external Cerbos service
- **Audit Logging**: Comprehensive audit trail for all administrative operations
- **Redis Caching**: High-performance caching for frequently accessed data
 * OpenAPI spec version: 1.0.0
 */
import type {
  ActionCreateRequest,
  ActionListResponse,
  ActionUpdateRequest,
  AppRoutersActionsActionResponse,
  HTTPValidationError,
  ListActionsApiV1ActionsGetParams,
} from '.././models'

import { customFetchHeimdall } from '../../../custom-fetch-heimdall'

/**
 * Create a new action that can be used in authorization policies and endpoint mappings.

**Actions**: Define granular permissions available in the system. Examples include
`user:read`, `group:create`, `data:export`, etc.

**Authorization**: Requires admin privileges to create actions.

**Naming Convention**: Use colon-separated format like `resource:operation`
(e.g., `user:read`, `group:create`, `data:export`).

**Use Cases**:
- Define new permissions for application features
- Create fine-grained access controls
- Integrate with external authorization systems
- Map API endpoints to specific actions

**Endpoint Mapping**: Actions can be mapped to API endpoints using the mappings API.
 * @summary Create a new action
 */
export type createActionApiV1ActionsPostResponse201 = {
  data: AppRoutersActionsActionResponse
  status: 201
}

export type createActionApiV1ActionsPostResponseComposite =
  createActionApiV1ActionsPostResponse201

export type createActionApiV1ActionsPostResponse =
  createActionApiV1ActionsPostResponseComposite & {
    headers: Headers
  }

export const getCreateActionApiV1ActionsPostUrl = () => {
  return `/api/v1/actions/`
}

export const createActionApiV1ActionsPost = async (
  actionCreateRequest: ActionCreateRequest,
  options?: RequestInit
): Promise<createActionApiV1ActionsPostResponse> => {
  return customFetchHeimdall<createActionApiV1ActionsPostResponse>(
    getCreateActionApiV1ActionsPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(actionCreateRequest),
    }
  )
}

/**
 * Retrieve a paginated list of all actions available in the system.

**Authorization**: All authenticated users can list actions.

**Pagination**: Use `skip` and `limit` parameters to control pagination.
Maximum limit is 100 actions per request.

**Action Information**: Each action includes its name, description, and the
number of API endpoints currently mapped to it.

**Use Cases**:
- Display available actions in administrative interfaces
- Integration with external authorization systems
- Action selection during endpoint mapping configuration
- Audit and compliance reporting
- Permission management workflows
 * @summary List all actions
 */
export type listActionsApiV1ActionsGetResponse200 = {
  data: ActionListResponse
  status: 200
}

export type listActionsApiV1ActionsGetResponseComposite =
  listActionsApiV1ActionsGetResponse200

export type listActionsApiV1ActionsGetResponse =
  listActionsApiV1ActionsGetResponseComposite & {
    headers: Headers
  }

export const getListActionsApiV1ActionsGetUrl = (
  params?: ListActionsApiV1ActionsGetParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/actions/?${stringifiedParams}`
    : `/api/v1/actions/`
}

export const listActionsApiV1ActionsGet = async (
  params?: ListActionsApiV1ActionsGetParams,
  options?: RequestInit
): Promise<listActionsApiV1ActionsGetResponse> => {
  return customFetchHeimdall<listActionsApiV1ActionsGetResponse>(
    getListActionsApiV1ActionsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

/**
 * Retrieve detailed information about a specific action by its ID.

**Authorization**: All authenticated users can read action information.

**Action Details**: Returns the action's name, description, and number of
API endpoints currently mapped to this action.

**Use Cases**:
- Display action details in administrative interfaces
- Validate action existence before creating mappings
- Integration with external systems
- Audit and compliance workflows
 * @summary Get action by ID
 */
export type getActionApiV1ActionsActionIdGetResponse200 = {
  data: AppRoutersActionsActionResponse
  status: 200
}

export type getActionApiV1ActionsActionIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getActionApiV1ActionsActionIdGetResponseComposite =
  | getActionApiV1ActionsActionIdGetResponse200
  | getActionApiV1ActionsActionIdGetResponse422

export type getActionApiV1ActionsActionIdGetResponse =
  getActionApiV1ActionsActionIdGetResponseComposite & {
    headers: Headers
  }

export const getGetActionApiV1ActionsActionIdGetUrl = (actionId: number) => {
  return `/api/v1/actions/${actionId}`
}

export const getActionApiV1ActionsActionIdGet = async (
  actionId: number,
  options?: RequestInit
): Promise<getActionApiV1ActionsActionIdGetResponse> => {
  return customFetchHeimdall<getActionApiV1ActionsActionIdGetResponse>(
    getGetActionApiV1ActionsActionIdGetUrl(actionId),
    {
      ...options,
      method: 'GET',
    }
  )
}

/**
 * Update an existing action's name and/or description.

**Authorization**: Requires admin privileges to update actions.

**Partial Updates**: You can update just the name, just the description, or both.
Provide only the fields you want to update.

**Impact**: Updating an action name may affect existing endpoint mappings and
authorization policies that reference this action.

**Use Cases**:
- Refine action descriptions for better clarity
- Rename actions to follow updated naming conventions
- Administrative maintenance of the action catalog
 * @summary Update action
 */
export type updateActionApiV1ActionsActionIdPutResponse200 = {
  data: AppRoutersActionsActionResponse
  status: 200
}

export type updateActionApiV1ActionsActionIdPutResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type updateActionApiV1ActionsActionIdPutResponseComposite =
  | updateActionApiV1ActionsActionIdPutResponse200
  | updateActionApiV1ActionsActionIdPutResponse422

export type updateActionApiV1ActionsActionIdPutResponse =
  updateActionApiV1ActionsActionIdPutResponseComposite & {
    headers: Headers
  }

export const getUpdateActionApiV1ActionsActionIdPutUrl = (actionId: number) => {
  return `/api/v1/actions/${actionId}`
}

export const updateActionApiV1ActionsActionIdPut = async (
  actionId: number,
  actionUpdateRequest: ActionUpdateRequest,
  options?: RequestInit
): Promise<updateActionApiV1ActionsActionIdPutResponse> => {
  return customFetchHeimdall<updateActionApiV1ActionsActionIdPutResponse>(
    getUpdateActionApiV1ActionsActionIdPutUrl(actionId),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(actionUpdateRequest),
    }
  )
}

/**
 * Delete an action from the system.

**Authorization**: Requires admin privileges to delete actions.

**Impact**: Deleting an action will also remove all endpoint mappings that
reference this action. This may affect authorization policies.

**Cascading Deletion**: The system will automatically clean up related
mappings and update authorization policies.

**Use Cases**:
- Remove obsolete actions
- Clean up unused permissions
- Administrative maintenance of the action catalog

**Warning**: This operation cannot be undone. Ensure the action is no longer
needed before deletion.
 * @summary Delete action
 */
export type deleteActionApiV1ActionsActionIdDeleteResponse204 = {
  data: null
  status: 204
}

export type deleteActionApiV1ActionsActionIdDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteActionApiV1ActionsActionIdDeleteResponseComposite =
  | deleteActionApiV1ActionsActionIdDeleteResponse204
  | deleteActionApiV1ActionsActionIdDeleteResponse422

export type deleteActionApiV1ActionsActionIdDeleteResponse =
  deleteActionApiV1ActionsActionIdDeleteResponseComposite & {
    headers: Headers
  }

export const getDeleteActionApiV1ActionsActionIdDeleteUrl = (
  actionId: number
) => {
  return `/api/v1/actions/${actionId}`
}

export const deleteActionApiV1ActionsActionIdDelete = async (
  actionId: number,
  options?: RequestInit
): Promise<deleteActionApiV1ActionsActionIdDeleteResponse> => {
  return customFetchHeimdall<deleteActionApiV1ActionsActionIdDeleteResponse>(
    getDeleteActionApiV1ActionsActionIdDeleteUrl(actionId),
    {
      ...options,
      method: 'DELETE',
    }
  )
}
