/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Heimdall Admin Service
 * # Heimdall Admin Service API

A comprehensive admin service for user and group management with authorization powered by Cerbos.

## Features

- **User Management**: Automatic user creation from JWT tokens with role-based access control
- **Group Management**: Create, manage, and assign users to groups with hierarchical permissions
- **Role Management**: Define and assign roles to users and groups
- **Mapping Management**: Configure API endpoint to action mappings for authorization
- **Action Management**: Define available actions for fine-grained permission control
- **Cerbos Integration**: Policy-based authorization with external Cerbos service
- **Audit Logging**: Comprehensive audit trail for all administrative operations
- **Redis Caching**: High-performance caching for frequently accessed data
 * OpenAPI spec version: 1.0.0
 */
import type {
  GroupCreateRequest,
  GroupResponse,
  HTTPValidationError,
  ListGroupsApiV1GroupsGetParams,
} from '.././models'

import { customFetchHeimdall } from '../../../custom-fetch-heimdall'

/**
 * Create a new group in the system.

**Authorization Required**: Users must have permission to create groups via Cerbos policies.

**Notes**:
- Group names must be unique across the system
- Names can only contain alphanumeric characters, hyphens, and underscores
- The creating user becomes the group owner
- Group creation is audited and logged

**Common Use Cases**:
- Creating departmental groups (e.g., "engineering", "marketing")
- Setting up project teams with specific access requirements
- Organizing users by geographical location or business unit
 * @summary Create a new group
 */
export type createGroupApiV1GroupsPostResponse201 = {
  data: GroupResponse
  status: 201
}

export type createGroupApiV1GroupsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createGroupApiV1GroupsPostResponseComposite =
  | createGroupApiV1GroupsPostResponse201
  | createGroupApiV1GroupsPostResponse422

export type createGroupApiV1GroupsPostResponse =
  createGroupApiV1GroupsPostResponseComposite & {
    headers: Headers
  }

export const getCreateGroupApiV1GroupsPostUrl = () => {
  return `/api/v1/groups/`
}

export const createGroupApiV1GroupsPost = async (
  groupCreateRequest: GroupCreateRequest,
  options?: RequestInit
): Promise<createGroupApiV1GroupsPostResponse> => {
  return customFetchHeimdall<createGroupApiV1GroupsPostResponse>(
    getCreateGroupApiV1GroupsPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(groupCreateRequest),
    }
  )
}

/**
 * List all groups in the system with optional filtering.

**Filtering**: Use the `prefix` query parameter to filter groups by name prefix.

**Authorization**: All authenticated users can list groups.

**Performance**: Results are cached for optimal performance. Large result sets
may be paginated in future versions.

**Use Cases**:
- Display all available groups in admin interfaces
- Search for specific groups by name prefix
- Export group information for reporting
 * @summary List all groups
 */
export type listGroupsApiV1GroupsGetResponse200 = {
  data: GroupResponse[]
  status: 200
}

export type listGroupsApiV1GroupsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listGroupsApiV1GroupsGetResponseComposite =
  | listGroupsApiV1GroupsGetResponse200
  | listGroupsApiV1GroupsGetResponse422

export type listGroupsApiV1GroupsGetResponse =
  listGroupsApiV1GroupsGetResponseComposite & {
    headers: Headers
  }

export const getListGroupsApiV1GroupsGetUrl = (
  params?: ListGroupsApiV1GroupsGetParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/groups/?${stringifiedParams}`
    : `/api/v1/groups/`
}

export const listGroupsApiV1GroupsGet = async (
  params?: ListGroupsApiV1GroupsGetParams,
  options?: RequestInit
): Promise<listGroupsApiV1GroupsGetResponse> => {
  return customFetchHeimdall<listGroupsApiV1GroupsGetResponse>(
    getListGroupsApiV1GroupsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

/**
 * Delete a group from the system with cascading cleanup.

**Authorization**: Users can delete groups they have permission to manage.
Permissions are checked via Cerbos policies.

**Cascade Effects**:
- Removes all group members
- Removes all role assignments from the group
- Updates Cerbos policies to reflect the group deletion

**Use Cases**:
- Remove obsolete or unused groups
- Administrative group cleanup
- System reorganization

**Safety**: Group deletion is irreversible. Ensure the group is no longer needed before deletion.
 * @summary Delete a group
 */
export type deleteGroupApiV1GroupsGroupNameDeleteResponse204 = {
  data: null
  status: 204
}

export type deleteGroupApiV1GroupsGroupNameDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type deleteGroupApiV1GroupsGroupNameDeleteResponseComposite =
  | deleteGroupApiV1GroupsGroupNameDeleteResponse204
  | deleteGroupApiV1GroupsGroupNameDeleteResponse422

export type deleteGroupApiV1GroupsGroupNameDeleteResponse =
  deleteGroupApiV1GroupsGroupNameDeleteResponseComposite & {
    headers: Headers
  }

export const getDeleteGroupApiV1GroupsGroupNameDeleteUrl = (
  groupName: string
) => {
  return `/api/v1/groups/${groupName}`
}

export const deleteGroupApiV1GroupsGroupNameDelete = async (
  groupName: string,
  options?: RequestInit
): Promise<deleteGroupApiV1GroupsGroupNameDeleteResponse> => {
  return customFetchHeimdall<deleteGroupApiV1GroupsGroupNameDeleteResponse>(
    getDeleteGroupApiV1GroupsGroupNameDeleteUrl(groupName),
    {
      ...options,
      method: 'DELETE',
    }
  )
}
