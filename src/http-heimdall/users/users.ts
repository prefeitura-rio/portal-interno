/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Heimdall Admin Service
 * # Heimdall Admin Service API

A comprehensive admin service for user and group management with authorization powered by Cerbos.

## Features

- **User Management**: Automatic user creation from JWT tokens with role-based access control
- **Group Management**: Create, manage, and assign users to groups with hierarchical permissions
- **Role Management**: Define and assign roles to users and groups
- **Mapping Management**: Configure API endpoint to action mappings for authorization
- **Action Management**: Define available actions for fine-grained permission control
- **Cerbos Integration**: Policy-based authorization with external Cerbos service
- **Audit Logging**: Comprehensive audit trail for all administrative operations
- **Redis Caching**: High-performance caching for frequently accessed data
 * OpenAPI spec version: 1.0.0
 */
import type {
  HTTPValidationError,
  ListUsersApiV1UsersGetParams,
  PaginatedResponseUserResponse,
  UserResponse,
} from '.././models'

import { customFetchHeimdall } from '../../../custom-fetch-heimdall'

/**
 * Retrieve a paginated list of all users in the system.

**Pagination**: Uses `skip` and `limit` query parameters for pagination.
Default limit is 50 users per page, maximum is 100.

**Authentication**: Requires a valid JWT token.

**Role Aggregation**: Each user in the response includes both direct roles
and roles inherited through group memberships.

**Use Cases**:
- User management dashboards
- Administrative user listing
- User directory
- Bulk user operations
- Reporting and analytics

**Response Fields**:
- `items`: Array of user objects for the current page
- `total`: Total number of users in the system
- `skip`: Number of users skipped (offset)
- `limit`: Maximum number of users returned in this page
- `has_more`: Whether there are more users available
 * @summary List all users
 */
export type listUsersApiV1UsersGetResponse200 = {
  data: PaginatedResponseUserResponse
  status: 200
}

export type listUsersApiV1UsersGetResponse401 = {
  data: null
  status: 401
}

export type listUsersApiV1UsersGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type listUsersApiV1UsersGetResponse500 = {
  data: null
  status: 500
}

export type listUsersApiV1UsersGetResponseComposite =
  | listUsersApiV1UsersGetResponse200
  | listUsersApiV1UsersGetResponse401
  | listUsersApiV1UsersGetResponse422
  | listUsersApiV1UsersGetResponse500

export type listUsersApiV1UsersGetResponse =
  listUsersApiV1UsersGetResponseComposite & {
    headers: Headers
  }

export const getListUsersApiV1UsersGetUrl = (
  params?: ListUsersApiV1UsersGetParams
) => {
  const normalizedParams = new URLSearchParams()

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `/api/v1/users/?${stringifiedParams}`
    : `/api/v1/users/`
}

export const listUsersApiV1UsersGet = async (
  params?: ListUsersApiV1UsersGetParams,
  options?: RequestInit
): Promise<listUsersApiV1UsersGetResponse> => {
  return customFetchHeimdall<listUsersApiV1UsersGetResponse>(
    getListUsersApiV1UsersGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  )
}

/**
 * Retrieve detailed information about the currently authenticated user based on their JWT token.

**Authentication**: Uses the JWT token to automatically identify the user by their CPF
from the `preferred_username` field in the Keycloak token.

**Auto-Retrieval**: No need to specify the CPF - it's automatically extracted from the JWT token.

**Auto-Creation**: If the user doesn't exist in the system, they are automatically created
during the authentication process.

**Role Aggregation**: The response includes both direct roles assigned to the user and
roles inherited through group memberships.

**Use Cases**:
- User profile display in self-service applications
- Current user context for frontend applications
- Session management and user state tracking
- Self-service user information retrieval
- Profile settings and preferences display

**Security**: Only returns information about the authenticated user - no access to other users' data.
 * @summary Get current user information
 */
export type getCurrentUserInfoApiV1UsersMeGetResponse200 = {
  data: UserResponse
  status: 200
}

export type getCurrentUserInfoApiV1UsersMeGetResponseComposite =
  getCurrentUserInfoApiV1UsersMeGetResponse200

export type getCurrentUserInfoApiV1UsersMeGetResponse =
  getCurrentUserInfoApiV1UsersMeGetResponseComposite & {
    headers: Headers
  }

export const getGetCurrentUserInfoApiV1UsersMeGetUrl = () => {
  return `/api/v1/users/me`
}

export const getCurrentUserInfoApiV1UsersMeGet = async (
  options?: RequestInit
): Promise<getCurrentUserInfoApiV1UsersMeGetResponse> => {
  return customFetchHeimdall<getCurrentUserInfoApiV1UsersMeGetResponse>(
    getGetCurrentUserInfoApiV1UsersMeGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  )
}

/**
 * Retrieve detailed information about a user by their CPF (Brazilian tax ID).

**User Identification**: Users are identified by their CPF (Cadastro de Pessoa Física),
which is extracted from the `preferred_username` field in Keycloak JWT tokens.

**Authorization**: All authenticated users can retrieve user information.

**Auto-Creation**: Users are automatically created when they first authenticate with a valid JWT token.

**Role Aggregation**: The response includes both direct roles assigned to the user and
roles inherited through group memberships.

**Use Cases**:
- User profile display in applications
- Administrative user management
- Role and permission verification
- Group membership tracking
- Integration with external systems requiring user data
 * @summary Get user by CPF
 */
export type getUserByCpfApiV1UsersCpfGetResponse200 = {
  data: UserResponse
  status: 200
}

export type getUserByCpfApiV1UsersCpfGetResponseComposite =
  getUserByCpfApiV1UsersCpfGetResponse200

export type getUserByCpfApiV1UsersCpfGetResponse =
  getUserByCpfApiV1UsersCpfGetResponseComposite & {
    headers: Headers
  }

export const getGetUserByCpfApiV1UsersCpfGetUrl = (cpf: string) => {
  return `/api/v1/users/${cpf}`
}

export const getUserByCpfApiV1UsersCpfGet = async (
  cpf: string,
  options?: RequestInit
): Promise<getUserByCpfApiV1UsersCpfGetResponse> => {
  return customFetchHeimdall<getUserByCpfApiV1UsersCpfGetResponse>(
    getGetUserByCpfApiV1UsersCpfGetUrl(cpf),
    {
      ...options,
      method: 'GET',
    }
  )
}
